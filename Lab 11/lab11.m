% Script for testing observers for the propeller system 
clear all;
close all;

% Third order model of propellor system
% States [Angle (Theta), Rotational velocity (Omega), Back EMF]
% Using a "descriptor" system:
% E dx/dt = A x + B u,
% y = Cx + Du,
% where E is 3x3, A is 3x3, B is 3x1 and C is 1x3

% Parameters
Ke = 5.5e-3;  % back-emf per radian/sec motor rotational velocity
Km = 5.5e-3;  % Torque per amp
Jm = 3e-6;  % Motor moment of inertia
La1 = 0.15;   % Arm lengtJh in meters (one)
La2 = 0.0;     %Arm length in meters (two)
Ja = 4.5e-4; %1/3*(0.014)*La1^3 + 0.016*La1^2 + 1/3*(0.014)*La2^3 + 0.016*La2^2;
Rm = 1;      % Motor resistance
Rs = 1;      % Series resistance
Kf = 10e-6;  % Motor Friction
Kt = 1.8e-3;

% E matrix, multiplies by dx/dt
E = eye(3);
E(2,2) = Ja;
E(3,3) = Jm;

% Motor DC resistance is 0.5 ohms plus a one-ohm shunt resistor (in series)
% Motor Back-EMF = (EMF generated by rotational velocity Omega)

% Jm d/dt Vbemf = -((Ke*Km)/(Rtotal) + Kf) Vemf + (Ke*Km)/(Rtotal) Vpwm
A(3,:) = [0 0 -(Ke*Km/(Rs+Rm)+ Kf)];
B = [0 0 Ke*Km/(Rs+Rm)]';

% Ja d/dt omega = Kt*La/Ke Vbemf
A(2,3) = Kt*La1/Ke;

% Dtheta/dt = Omega.
A(1,2) = 1;

% Output is voltage from angle sensor, approximately one volt per radian.
C = [1 0 0];

% Direct term (D) is zero.
D = 0;

% Convert to a system (invert E to create normal form)
prop_sys = dss(A, B, C, D, E, 'StateName', {'Arm Angle', 'Arm Rot. Vel', 'Vemf'});

% ======================
% Convert plant transfer function to DT state space model
% =====================

% Discretize
DeltaT = 1.0e-3;
prop_sys_d = c2d(prop_sys, DeltaT);
Ad = prop_sys_d.a;
Bd = prop_sys_d.b;
Cd = prop_sys_d.c;
Dd = prop_sys_d.d;
Nstates = size(Ad, 1);

% Poles of original system
disp('Poles of the DT Open Loop System');
disp(pole(prop_sys_d));


% =========
% Compute the gains for state feedback: u = -K*x + Kr*r
% =========

% 3x3 Q matrix Q(i,i) = 1, 1x1 R matrix, R(i,i) = 1, (identity matrices)
%************************ Fix This! (Pick good weights. - LOOK AT GRAPHS
Q = diag([1000.0,10.0,1.0]);  
R = 1.0;
Kd = dlqr(Ad,Bd,Q,R); 
disp('Kd Gains');
disp(Kd);

% Compute closed-loop matrix to compute Kr
Adcl = Ad - Bd*Kd;
disp('poles of the DT measured-state-feedback system');
disp(eig(Adcl));

Krd = inv(Cd*inv(eye(3)-Ad+Bd*Kd)*Bd) ;  % ***********FIX THIS!!!!!!! USE FORMULA

% =========
% Compute the gains for the observer system 
% xhat[n] = Ad*xhat[n-1] + Bd*u[n-1] + Ld*[y[n-1]-yhat[n-1])
% =========

%************************************ FIX THIS!!!!
Ld = place(Ad',Cd', eig(Adcl)*0.9)';%[0, 1, 0]'; % You'll need to pick the observer gains!!! USE PLACE AND LQR TO FIND GAINS
disp('Ld gains');
disp(Ld');

% Compute closed-loop matrix 
AdObserver = Ad-Ld*Cd; %************************************ FIX THIS!!!!
disp('poles of the DT estimation error system');
disp(eig(AdObserver));

% =========
% Simulation
% =========
numSteps = 500;  % Time interval equals numSteps * DeltaT
in = zeros(numSteps,1);
in(floor(numSteps/2):end) = 1.0;
xSave = zeros(size(Ad,1),numSteps);
xhatSave = 0.0*xSave;
xrSave = 0.0*xSave;
uSave = zeros(numSteps,1);
urSave = zeros(numSteps,1);
t = (0:numSteps-1)*DeltaT;

% xhat are the state estimates
% x are the states using state-feedback with estimated states.
% xr are the states using state-feedback with measured states.
x = [1, 1, 1]';  % Initial condition on real state
xHat = 0.5*x;    % Initial condition on estimated state
xr = [1, 1, 1]'; % Initial conditions of measured-state feedback state

for i = 1:numSteps-1
    
    % Micro computes: control, u, and output estimate, yhat.
    u = Krd*in(i) - Kd*xHat;   % Output update with estimated state
    yhat = Cd*xHat; %Output prediction update
    
    % Measure the output of the physical systemn
    y = Cd*x;  % Measurement of simulated physical system
    
    % Save data for plotting later.
    uSave(i) = u;
    xSave(:,i) = x;
    xhatSave(:,i) = xHat;

    
    % Micro updates the state estimation.
    xHat = Ad*xHat + Bd*u + Ld*(y-yhat); %Observer update
    
    % Simulation of plant (not a mcirocontroller computation)
    x = Ad*x + Bd*u;   % Plant update with estimated-state control
    
    % Measured-state feedback, saved for comparison purposes.
    xrSave(:,i) = x;
    ur = Krd*in(i) - Kd*xr;  % Output update with measured ("real") state.
    urSave(i) = ur;
    xr = Ad*xr + Bd*ur;% Plant model update measured-state control

end


% Plots comparing state estimates, estimated-state feedback control, and
% measured-state feedback control.
% and 
figure(3); clf;
subplot(4,1,1);
plot(t, xSave(1,:),'r',t, xrSave(1,:),'b',t,xhatSave(1,:),'g');
axis('tight');
title('Angle using est-state fdbk (r), using meas-state-fdbk(b), and estimated angle (g)')
subplot(4,1,2);
plot(t, xSave(2,:),'r',t, xrSave(2,:),'b', t,xhatSave(2,:),'g');
axis('tight');
title('Omega using est-state fdbk (r), using meas-state-fdbk(b), and estimated omega (g)')
subplot(4,1,3);
plot(t, xSave(3,:),'r',t, xrSave(3,:),'b',t,xhatSave(3,:),'g');
title('Vbemf using est-state fdbk (r), using meas-state-fdbk(b), and estimated Vbemf(g)')
subplot(4,1,4);
plot(t, uSave,'r',t, urSave,'b');
title('u(t) using est-state fdbk (r), and u(t) using meas-state-fdbk(b)')