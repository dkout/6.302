% Script to compute propeller system using pole placement.

% Third order model of propellor system

% States: [Angle (Theta_a), 
%          Rotational velocity (Omega_a), 
%          back-EMF (deltaVemf)]

% Using a "descriptor" system:
% E dx/dt = A x + B u,
% y = Cx + Du,
% where E is 3x3, A is 3x3, B is 3x1 and C is 1x3

close all;

% Parameters
Ke = 5.5e-3;  % back-emf per radian/sec motor rotational velocity
Km = 5.5e-3;  % Torque per amp
Jm = 3e-6;  % Motor moment of inertia
Ja = 4.5e-4; % Arm moment of inertia
Rm = 1;      % Motor resistance
Rs = 1;      % Series resistance
La = 0.15;   % Arm length in meters
Kf = 10e-6;  % Motor Friction
Kt = 1.8e-3;

% E matrix, multiplies by dx/dt
E = eye(3);
E(2,2) = Ja;
E(3,3) = Jm;

% Motor DC resistance is one ohm plus a one-ohm shunt resistor (in series)
% Motor Back-EMF = (EMF generated by rotational velocity Omega)

% Dtheta/dt = Omega.
A(1,2) = 1;

% Ja d/dt omega = Kt*La/Ke Vbemf
A(2,3) = Kt*La/Ke;

% Jm d/dt Vbemf = -((Ke*Km)/(Rtotal) + Kf) Vemf + (Ke*Km)/(Rtotal) Vpwm
A(3,:) = [0 0 -(Ke*Km/(Rs+Rm)+ Kf)];
B = [0 0 Ke*Km/(Rs+Rm)]';

% Output is voltage from angle sensor, approximately one volt per radian.
C = [1 0 0];

% The instantaneous u-to-y term (D) is zero.
D = 0;

% Convert to a system
motor_sys = dss(A, B, C, D, E, 'StateName', {'Arm Angle', 'Arm Rot. Vel', 'Vemf'});
display(motor_sys);

% Print input-output transfer function.
%tf(motor_sys)

% Determine poles
disp('Poles of the Open Loop System')
disp(pole(motor_sys));

% Bode plot of transfer function
%figure;
%bode(motor_sys);

% State weights*********FIX THIS!!!**************
Q = zeros(3,3);
Q(1,1) = 1000;
Q(2,2) = 10;
Q(3,3) = 1;

% Plant input weights ************FIX THIS!!*********
R(1,1) = 1;

% Compute K with pole placer or lqr (placer and lqr require E=I, notice division by E)
%K = place(E\A,E\B,[-1,-1.1,-1.2]);
K = lqr(E\A, E\B,Q,R);
disp('Gains');
disp(K);

% Compute Closed Loop Matrix
Acl = A-B*K;  

% Compute input scaling so that theta_d  - theta_a = 0 in steady-state.
Kr = 1/(-C*(Acl\B));

% Make every state an output so they will be plotted by step command.
Cplot = eye(3); 

% Vpwm = Kr*Theta_d - K*x, make the -K*x part an output for plotting
Cplot(4,:) = K; % Last output should give -K*x part of Vpwm 

% Closed Loop systen
    sys_cl = dss(Acl, B*Kr, Cplot, D, E, 'OutputName', {'Arm Angle', 'Arm Rot. Vel', 'Vemf', '-K*x part of Vpwm'});
    disp('Poles of the Closed-Loop System');
    disp(pole(sys_cl));

    % Plot step response of all three states and the -K*x part of Vpwm.
    figure;
    step(sys_cl);
    display(K);
    display(Kr);

    disp('Done For Controller with No Integrator');
    disp('');

% This is for the integrator, add the extra state
Bp = [B;  0];
Cp = [C 0];
Dp = D;
Ep = [E [0 0 0]'; 0 0 0 1];
Ap = [A [0,0,0]'; C,0]; %*********FIX THIS!****

% State weights*********FIX THESE!****
Qp = zeros(4,4);
Qp(1,1) = 1;
Qp(2,2) = 1;
Qp(3,3) = 1;
Qp(4,4) = 10000;

% Plant input weights*********FIX THESE!****
Rp(1,1) = 1;

%Compute Kp
Kp = lqr(Ep\Ap, Ep\Bp,Qp,Rp);
%Kp = [0,0,0,0];  %************ FIX (just remove)

% Compute the closed-loop matrices
Aclp = Ap-Bp*Kp;
Cplotp = eye(4);
Cplotp(5,:) = Kp;

% Modify Bclp to include the primary input to integrator equation.
Bclp = [0,0,0,-1]'; %***********FIX THIS!!***********

% Closed Loop systen
sys_clp = dss(Aclp, Bclp, Cplotp, Dp, Ep, 'OutputName', {'Arm Angle', 'Arm Rot. Vel', 'Vemf', 'Integral', '-K*x part of Vpwm'});
disp('Poles of the Closed-Loop System');
disp(pole(sys_clp));

% Plot step response of all three states and the -K*x part of Vpwm.
figure;
step(sys_clp);
display(Kp);

disp('Done With Integrator Case');
disp('');


% Compute Krp to make the step response of the integrator returbn to zero.
Krp = 1/(-(C*((A-B*Kp(1:3))\B))); 
Bclp = [0,0,0,-1]'; % %***********FIX THIS!!***********
display(Krp);

% Closed Loop systen
sys_clpp = dss(Aclp, Bclp, Cplotp, Dp, Ep, 'OutputName', {'Arm Angle','Arm Rot. Vel','Vemf','Integral','-K*x part of Vpwm'});

% Plot step response of all three states and the -K*x part of Vpwm.
figure;
step(sys_clpp);